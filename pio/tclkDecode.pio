;
; TclkDecode PIO program for Raspberry Pi Pico
; 
; This PIO program processes timestamps from tclkIN and decodes
; data according to the TCLK protocol as described in TCLK_Paper.pdf:
; - Uses bi-phase (modified Manchester) coding
; - Transition at each bit cell boundary
; - Additional transition at mid-cell if bit is 1, no transition if bit is 0
; - Word length is 12 bits:
;   * 1 start bit (always 0)
;   * 8 data bits
;   * 1 parity bit (odd parity)
;   * 2 guaranteed '1's after each event
;

.program tclkDecode
.define PUBLIC BIT_CELL 50       ; Bit cell duration in nanoseconds (half of bit period)
.define PUBLIC BIT_PERIOD 100    ; Full bit period in nanoseconds
.define PUBLIC MID_CELL_MARGIN 25 ; Margin for detecting mid-cell transitions (Â±25ns)

.wrap_target
    ; Wait for a start bit (0)
wait_for_start:
    pull                         ; Pull timestamp from FIFO
    mov x, osr                   ; Store timestamp in X
    pull                         ; Pull next timestamp from FIFO
    mov y, osr                   ; Store timestamp in Y
    
    mov isr, y                   ; Store y in ISR temporarily
    mov y, x                     ; Move x to y
    mov x, isr                   ; Move original y to x
    sub x, y                     ; Calculate time difference (x = x - y)
    mov y, x                     ; Store result in y
    
    ; Check if this is a bit boundary transition
    ; We expect transitions at bit boundaries (every BIT_PERIOD)
    ; and possibly at mid-cell (BIT_CELL after bit boundary)
    
    ; If time difference is close to BIT_PERIOD, it's a bit boundary without mid-cell transition (0 bit)
    ; If time difference is close to BIT_CELL, it's a mid-cell transition (1 bit)
    
    ; Check if this could be a start bit (0)
    ; For a start bit, we expect no mid-cell transition, so time difference should be BIT_PERIOD
    set x, BIT_PERIOD            ; Load BIT_PERIOD into X
    mov isr, x                   ; Move to ISR
    mov x, y                     ; Move time_diff to x
    mov y, isr                   ; Move BIT_PERIOD to y
    sub x, y                     ; Calculate |BIT_PERIOD - time_diff| (x = x - y)
    jmp !x, found_start_bit      ; If close to BIT_PERIOD, it's a start bit
    
    ; Not a start bit, continue looking
    jmp wait_for_start
    
found_start_bit:
    ; We found a start bit (0), now decode the 8 data bits
    ; Initialize byte accumulator
    set x, 0                     ; X will hold our decoded byte
    set y, 8                     ; Set bit counter to 8
    
bit_loop:
    ; Get next transition
    pull                         ; Pull timestamp from FIFO
    mov isr, y                   ; Store previous timestamp in ISR
    mov y, osr                   ; Store new timestamp in Y
    
    mov x, y                     ; Store current timestamp in x
    mov y, isr                   ; Move previous timestamp to y
    sub x, y                     ; Calculate time difference (x = x - y)
    mov y, x                     ; Store result in y
    
    ; Check if this is a mid-cell transition (indicating a 1)
    set x, BIT_CELL              ; Load BIT_CELL into X
    mov isr, x                   ; Move to ISR
    set x, MID_CELL_MARGIN       ; Load MID_CELL_MARGIN into X
    mov y, isr                   ; Move BIT_CELL to y
    sub y, x                     ; Calculate lower bound (y = y - x)
    mov isr, y                   ; Store lower bound in ISR
    
    ; Compare y with lower bound
    mov x, y                     ; Copy y to x for comparison
    mov y, isr                   ; Move lower_bound to y
    sub x, y                     ; x = x - y (x = original_y - lower_bound)
    jmp !x, mid_cell_check_upper ; If y == lower_bound, check upper bound
    jmp x, mid_cell_check_upper  ; If y > lower_bound, check upper bound
    jmp not_mid_cell             ; If y < lower_bound, not a mid-cell transition
    
mid_cell_check_upper:
    set x, BIT_CELL              ; Load BIT_CELL into X
    mov isr, x                   ; Move to ISR
    set x, MID_CELL_MARGIN       ; Load MID_CELL_MARGIN into X
    mov y, isr                   ; Move BIT_CELL to y
    add y, x                     ; Calculate upper bound (y = y + x)
    mov isr, y                   ; Store upper bound in ISR
    
    ; Compare y with upper bound
    mov x, isr                   ; Copy upper_bound to x for comparison
    mov y, osr                   ; Restore original y value
    sub x, y                     ; x = x - y (x = upper_bound - original_y)
    jmp !x, mid_cell_transition  ; If y == upper_bound, it's a mid-cell transition
    jmp x, mid_cell_transition   ; If y < upper_bound, it's a mid-cell transition
    jmp not_mid_cell             ; If y > upper_bound, not a mid-cell transition
    
mid_cell_transition:
    ; This is a mid-cell transition, so bit is 1
    ; Shift in a 1 bit
    mov x, 1                     ; Set x to 1 for shifting in
    in x, 1                      ; Shift in a 1 bit
    
    ; Get the next bit boundary transition
    pull                         ; Pull timestamp from FIFO
    mov isr, y                   ; Store previous timestamp in ISR
    mov y, osr                   ; Store new timestamp in Y
    
    jmp bit_counter              ; Continue to bit counter
    
not_mid_cell:
    ; No mid-cell transition, so bit is 0
    ; Shift in a 0 bit
    mov x, 0                     ; Set x to 0 for shifting in
    in x, 1                      ; Shift in a 0 bit
    
bit_counter:
    ; Decrement bit counter and check if we're done
    jmp y--, bit_loop_check      ; Decrement bit counter
bit_loop_check:
    jmp !y, bit_loop_done        ; If counter is 0, we're done
    jmp bit_loop                 ; Otherwise continue loop
    
bit_loop_done:
    ; We've decoded 8 data bits, now check parity bit
    ; Get next transition
    pull                         ; Pull timestamp from FIFO
    mov isr, y                   ; Store previous timestamp in ISR
    mov y, osr                   ; Store new timestamp in Y
    
    mov x, y                     ; Store current timestamp in x
    mov y, isr                   ; Move previous timestamp to y
    sub x, y                     ; Calculate time difference (x = x - y)
    mov y, x                     ; Store result in y
    
    ; Check if this is a mid-cell transition (indicating a 1 parity bit)
    set x, BIT_CELL              ; Load BIT_CELL into X
    mov isr, x                   ; Move to ISR
    set x, MID_CELL_MARGIN       ; Load MID_CELL_MARGIN into X
    mov y, isr                   ; Move BIT_CELL to y
    sub y, x                     ; Calculate lower bound (y = y - x)
    mov isr, y                   ; Store lower bound in ISR
    
    ; Compare y with lower bound
    mov x, y                     ; Copy y to x for comparison
    mov y, isr                   ; Move lower_bound to y
    sub x, y                     ; x = x - y (x = original_y - lower_bound)
    jmp !x, parity_check_upper   ; If y == lower_bound, check upper bound
    jmp x, parity_check_upper    ; If y > lower_bound, check upper bound
    jmp parity_bit_zero          ; If y < lower_bound, parity bit is 0
    
parity_check_upper:
    set x, BIT_CELL              ; Load BIT_CELL into X
    mov isr, x                   ; Move to ISR
    set x, MID_CELL_MARGIN       ; Load MID_CELL_MARGIN into X
    mov y, isr                   ; Move BIT_CELL to y
    add y, x                     ; Calculate upper bound (y = y + x)
    mov isr, y                   ; Store upper bound in ISR
    
    ; Compare y with upper bound
    mov x, isr                   ; Copy upper_bound to x for comparison
    mov y, osr                   ; Restore original y value
    sub x, y                     ; x = x - y (x = upper_bound - original_y)
    jmp !x, parity_bit_one       ; If y == upper_bound, parity bit is 1
    jmp x, parity_bit_one        ; If y < upper_bound, parity bit is 1
    jmp parity_bit_zero          ; If y > upper_bound, parity bit is 0
    
parity_bit_one:
    ; Parity bit is 1
    mov isr, 1                   ; Store parity bit in ISR
    jmp check_parity
    
parity_bit_zero:
    ; Parity bit is 0
    mov isr, 0                   ; Store parity bit in ISR
    
check_parity:
    ; Calculate expected parity (odd parity)
    in null, 24                  ; Shift ISR right to make room for data byte
    mov y, isr                   ; Copy data byte to Y for parity calculation
    mov x, 0                     ; Initialize parity counter
parity_calc_loop:
    jmp !y, skip_parity_calc     ; Skip if bit is 0
    jmp !x, set_parity_one       ; If parity is 0, set to 1
    mov x, 0                     ; Otherwise set parity to 0
    jmp next_parity_calc_bit
set_parity_one:
    mov x, 1                     ; Set parity to 1
next_parity_calc_bit:
    jmp y--, parity_shift        ; Decrement bit counter
parity_shift:
    mov y, isr                   ; Reload data byte
    in y, 1                      ; Shift right by 1
    mov isr, y                   ; Store back to ISR
    jmp !y, skip_parity_calc     ; If no more bits, we're done
    jmp parity_calc_loop         ; Otherwise continue
skip_parity_calc:
    
    ; At this point, X contains the expected parity bit (1 for odd parity)
    ; Compare with actual parity bit in ISR
    mov y, isr                   ; Get actual parity bit
    jmp x!=y, parity_error       ; If parity doesn't match, discard byte
    
    ; Skip the two guaranteed '1's
    ; First '1'
    pull                         ; Pull timestamp for bit boundary transition
    pull                         ; Pull timestamp for mid-cell transition (should be there for a '1')
    
    ; Second '1'
    pull                         ; Pull timestamp for bit boundary transition
    pull                         ; Pull timestamp for mid-cell transition (should be there for a '1')
    
    ; We have a valid byte with correct parity, push it to the output FIFO
    in null, 24                  ; Shift ISR right to make room for data byte
    mov x, isr                   ; Move decoded byte to X
    push                         ; Push byte to output FIFO
    
    ; Ready for next byte
    jmp wait_for_start
    
parity_error:
    ; Parity error, discard this byte and skip the two '1's
    ; First '1'
    pull                         ; Pull timestamp for bit boundary transition
    pull                         ; Pull timestamp for mid-cell transition
    
    ; Second '1'
    pull                         ; Pull timestamp for bit boundary transition
    pull                         ; Pull timestamp for mid-cell transition
    
    ; Ready for next byte
    jmp wait_for_start
.wrap

% c-sdk {
static inline void tclkDecode_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = tclkDecode_program_get_default_config(offset);
    
    // Configure the state machine
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_RX); // Join FIFOs to increase size
    
    // Load the configuration and start the program
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Function to read a decoded byte from the PIO FIFO
static inline bool tclkDecode_get_byte(PIO pio, uint sm, uint8_t* byte) {
    // Check if there's data available
    if (pio_sm_is_rx_fifo_empty(pio, sm)) {
        return false;
    }
    
    // Read the byte
    *byte = pio_sm_get(pio, sm) & 0xFF;
    return true;
}

// Function to read multiple decoded bytes
static inline size_t tclkDecode_get_bytes(PIO pio, uint sm, uint8_t* buffer, size_t max_bytes) {
    size_t bytes_read = 0;
    
    while (bytes_read < max_bytes) {
        uint8_t byte;
        if (!tclkDecode_get_byte(pio, sm, &byte)) {
            // No more data available
            break;
        }
        
        buffer[bytes_read++] = byte;
    }
    
    return bytes_read;
}
%}

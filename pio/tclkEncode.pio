;
; TclkEncode PIO program for Raspberry Pi Pico
; 
; This PIO program encodes data using the TCLK protocol as described in TCLK_Paper.pdf:
; - Uses bi-phase (modified Manchester) coding
; - Transition at each bit cell boundary
; - Additional transition at mid-cell if bit is 1, no transition if bit is 0
; - Word length is 12 bits:
;   * 1 start bit (always 0)
;   * 8 data bits
;   * 1 parity bit (odd parity)
;   * 2 guaranteed '1's after each event
;
; The encoded data is output as timestamps for the tclkOUT program.
;

.program tclkEncode
.define PUBLIC BIT_CELL 50       ; Bit cell duration in nanoseconds (half of bit period)
.define PUBLIC BIT_PERIOD 100    ; Full bit period in nanoseconds
.define PUBLIC TCLK_FRAME_BITS 12 ; Total bits in a TCLK frame (1 start + 8 data + 1 parity + 2 trailer)

.wrap_target
    pull                         ; Pull a byte from FIFO
    mov x, osr                   ; Store byte in X
    
    ; Calculate parity bit (odd parity)
    mov y, x                     ; Copy byte to Y for parity calculation
    mov osr, 0                   ; Initialize parity counter
parity_loop:
    jmp !y, skip_parity_count    ; Skip if bit is 0
    jmp osr, toggle_parity       ; Toggle parity if it's 1
    set osr, 1                   ; Set parity to 1
    jmp next_parity_bit
toggle_parity:
    set osr, 0                   ; Set parity to 0
next_parity_bit:
    shr y, 1                     ; Shift to next bit
    jmp !osre parity_loop        ; Continue until all bits processed
skip_parity_count:
    shr y, 1                     ; Shift to next bit
    jmp !osre parity_loop        ; Continue until all bits processed
    
    ; At this point, OSR contains the parity bit (1 for odd parity)
    mov isr, osr                 ; Store parity bit in ISR
    
    ; Get current timestamp
    mov y, 0                     ; Start with timestamp 0 (relative timing)
    
    ; Send start bit (always 0)
    ; For a 0, we have transition at bit boundary but no transition at mid-cell
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_PERIOD            ; Add full bit period
    push                         ; Push timestamp for next bit boundary transition
    
    ; Send 8 data bits (LSB first)
    set osr, 8                   ; Set bit counter to 8 (tracks remaining bits to send)
bit_loop:
    ; Check if current bit is 1 or 0
    mov isr, x                   ; Copy data byte to ISR
    and isr, 1                   ; Isolate LSB
    jmp !isr, send_zero          ; If bit is 0, jump to send_zero
    
    ; Send a 1 bit (transition at bit boundary and mid-cell)
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_CELL              ; Add half bit period for mid-cell transition
    push                         ; Push timestamp for mid-cell transition
    add y, BIT_CELL              ; Add half bit period to complete the bit
    jmp next_bit
    
send_zero:
    ; Send a 0 bit (transition at bit boundary only)
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_PERIOD            ; Add full bit period (no mid-cell transition)
    
next_bit:
    shr x, 1                     ; Shift to next bit in data byte
    jmp osr--, bit_loop          ; Loop until all 8 bits are sent
    
    ; Send parity bit
    mov x, isr                   ; Retrieve parity bit from ISR
    jmp !x, send_parity_zero     ; If parity bit is 0, jump to send_parity_zero
    
    ; Send a 1 parity bit
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_CELL              ; Add half bit period for mid-cell transition
    push                         ; Push timestamp for mid-cell transition
    add y, BIT_CELL              ; Add half bit period to complete the bit
    jmp send_trailer
    
send_parity_zero:
    ; Send a 0 parity bit
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_PERIOD            ; Add full bit period (no mid-cell transition)
    
send_trailer:
    ; Send 2 guaranteed '1's (bits 11-12 of the TCLK frame)
    ; First '1' (bit 11)
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_CELL              ; Add half bit period for mid-cell transition
    push                         ; Push timestamp for mid-cell transition
    add y, BIT_CELL              ; Add half bit period to complete the bit
    
    ; Second '1' (bit 12 - completes the TCLK frame)
    push                         ; Push timestamp for bit boundary transition
    add y, BIT_CELL              ; Add half bit period for mid-cell transition
    push                         ; Push timestamp for mid-cell transition
    add y, BIT_CELL              ; Add half bit period to complete the bit
    push                         ; Push final timestamp
.wrap

% c-sdk {
static inline void tclkEncode_program_init(PIO pio, uint sm, uint offset) {
    pio_sm_config c = tclkEncode_program_get_default_config(offset);
    
    // Configure the state machine
    sm_config_set_fifo_join(&c, PIO_FIFO_JOIN_TX); // Join FIFOs to increase size
    
    // Load the configuration and start the program
    pio_sm_init(pio, sm, offset, &c);
    pio_sm_set_enabled(pio, sm, true);
}

// Function to send a byte to be encoded as a TCLK event
static inline void tclkEncode_send_byte(PIO pio, uint sm, uint8_t byte) {
    // Wait for space in the FIFO
    while (pio_sm_is_tx_fifo_full(pio, sm))
        tight_loop_contents();
    
    // Send the byte
    pio_sm_put(pio, sm, byte);
}

// Function to send multiple bytes to be encoded as TCLK events
static inline void tclkEncode_send_bytes(PIO pio, uint sm, const uint8_t* buffer, size_t length) {
    for (size_t i = 0; i < length; i++) {
        tclkEncode_send_byte(pio, sm, buffer[i]);
    }
}
%}
